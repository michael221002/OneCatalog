<div class="topbar" [ngClass]="{'nav': true, 'scroll': isScrolled}">
    <img src="./assets/logo.png">
    <div class="content">
        <button mat-raised-button color="primary" (click)="scrollToSection('intro')">Intro</button>
        <button mat-raised-button color="primary" (click)="scrollToSection('structure')">Structure</button>
        <button mat-raised-button color="primary" (click)="scrollToSection('material')">Angular Material</button>
        <button mat-raised-button color="primary" (click)="scrollToSection('architecture')">Architecture</button>
        <button mat-raised-button color="primary" (click)="scrollToSection('angular')">Angularconcepts</button>
        <button mat-raised-button color="primary" (click)="scrollToSection('forms')">Forms</button>
        <button mat-raised-button color="primary" (click)="scrollToSection('requests')">Requests</button>
    </div>
</div>


<div class="IntroSection"id="intro">
    <div class="cover">
        <span class="title">
            Tutorial
        </span>
    </div>
    <br>
    <div class="IntroText">
        <h1>
            Hallo Ihr Lieben, ich habe mal ein Tutorial vorbereitet, speziell für unser Projekt
            aber auch mit ein paar allgemeinen Infos. Hier habe ich mal versucht alles rein zu packen was
            ich was für das Projekt wichtig ist und was für euch ganz interessant sein könnte.
        </h1>
    </div>
</div>

<br>

<div class="main">
    <div class="content">

        <div class="StructureSection" id="structure">
            <div class="box">
                <div class="ThemeSection">
                    <h1>
                        <span class="circle"></span> Angular Material
                    </h1>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>What is Angular Material and how we ca install it</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>How we can use the Material Buttons</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>How we can use the Material Icons and style theme</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>How we can use the Material Tabs</pre> 
                </div>
                <div class="ThemeSection">
                    <h1>
                        <span class="circle"></span> Architecture
                    </h1>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Objectorientation generell</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Objectorientation in Typescript</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Whats are Models and why we use them</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>What are Services and why we use them</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Why we didn't want all in one file</pre>
                </div>
                <div class="ThemeSection">
                    <h1>
                        <span class="circle"></span> Concepts in Angular
                    </h1>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Object Orientated Programming in Angular</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Services in Angular</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Dependency-Injection in Angular</pre> 
                </div>
                <div class="ThemeSection">
                    <h1>
                        <span class="circle"></span> Forms
                    </h1>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Build a simple Form</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Build a dynamical Form based on Models</pre>
                </div>
                <div class="ThemeSection">
                    <h1>
                        <span class="circle"></span> Requests
                    </h1>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>Important Knoledge to Understand</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>How to open a Request</pre>
                    <pre class="under"><span class="tab"></span><span class="circle"></span>How to implement Models</pre> 
                </div>
                <div class="ThemeSection">
                    <h1>
                        <span class="circle"></span> Tests
                    </h1>
                </div>
            </div>
        </div>
        <br>
        <div class="line"></div>
        <br>


<!--=====================================================================MATERIAL===============================================================================================-->
        <div class="capSection" id="material">
            <h1>Angular Material</h1>
            <br>
            <h3>
                Angular Material ist ein UI-Framework für Angular-Anwendungen, das eine Sammlung von vorgefertigten Material Design-Komponenten und -Stilen bereitstellt. Es bietet eine große Auswahl an Komponenten wie Buttons, Formulare, Dialoge, Navigationsleisten, Tabellen und vieles mehr.

                Angular Material verwendet das Material Design-Konzept von Google, das eine klare und intuitive Benutzeroberfläche fördert und die Benutzerfreundlichkeit verbessert. Die Komponenten sind responsive und passen sich automatisch an verschiedene Bildschirmgrößen an.
                
                Angular Material ist vollständig in Angular integriert und bietet eine einfache Möglichkeit, benutzerdefinierte Designs und Stile zu erstellen. Es bietet auch eine schnelle und effiziente Entwicklung durch eine einheitliche API und automatische Generierung von CSS-Klassen.
                
                Das Framework wird durch die offizielle Angular-Entwicklergemeinschaft betrieben und ist auf npm (Node Package Manager) verfügbar. Es kann einfach in ein Angular-Projekt integriert werden, indem man es installiert und die benötigten Module importiert.
            </h3>
            <br>
            <h2>How to Install Angular Material</h2>
            <h3>
                Wir können Angular Material installieren indem wir folgenden Befehl
                in einem bestehenden Angular Projekt ausführen.
            </h3>
            <div class="codebox" id="installAngularMaterial">
                <div class="codeLine">
                    <h2>
                        {{snippets[0]}}
                    </h2>
                    <button mat-raised-button><span style="color:black"><mat-icon color="">content_copy</mat-icon></span></button>
                </div>
            </div>
            <br>
            <h2>How to use Angular Material Buttons</h2>
            <h3>
                Wir können Angular Material Buttons in dem wir sie wie folge implementieren<br>
                Zuerst müssen wir die MatButtonKomponente importieren. Dazu navigieren wir zur
                app.module.ts und importieren das Modul. Anschließend sagen wir Angular, dass es diese Modul in jeder Komponente zur
                Verfügung stellen soll.
            </h3>
            <br>
            <ace-editor [(text)]="importMatButton" id="materialButtons"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Mit dem folgenden Befehl können die Buttons nun angewenden werden
            </h3>
            <ace-editor [(text)]="snippets[3]"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Im folgenden werden alle möglichen Buttons aufgelistet
            </h3>
            <br>
            <section>
                <div class="example-label">"mat-button"</div>
                <div class="example-button-row">
                  <button mat-button style="color:white">Basic</button>
                  <button mat-button color="primary">Primary</button>
                  <button mat-button color="accent">Accent</button>
                  <button mat-button color="warn">Warn</button>
                  <button mat-button disabled>Disabled</button>
                  <a mat-button href="https://www.google.com/" target="_blank">Link</a>
                </div>
            </section>
            <section>
                <div class="example-label">"mat-raised-button"</div>
                <div class="example-button-row">
                  <button mat-raised-button>Basic</button>
                  <button mat-raised-button color="primary">Primary</button>
                  <button mat-raised-button color="accent">Accent</button>
                  <button mat-raised-button color="warn">Warn</button>
                  <button mat-raised-button disabled>Disabled</button>
                  <a mat-raised-button href="https://www.google.com/" target="_blank">Link</a>
                </div>
            </section>
            <section>
              <div class="example-label">"mat-raised-button"</div>
              <div class="example-button-row">
                <button mat-stroked-button style="color:white">Basic</button>
                <button mat-stroked-button color="primary">Primary</button>
                <button mat-stroked-button color="accent">Accent</button>
                <button mat-stroked-button color="warn">Warn</button>
                <button mat-stroked-button disabled>Disabled</button>
                <a mat-stroked-button href="https://www.google.com/" target="_blank">Link</a>
              </div>
            </section>
            <section>
              <div class="example-label">"mat-flat-button"</div>
              <div class="example-button-row">
                <button mat-flat-button>Basic</button>
                <button mat-flat-button color="primary">Primary</button>
                <button mat-flat-button color="accent">Accent</button>
                <button mat-flat-button color="warn">Warn</button>
                <button mat-flat-button disabled>Disabled</button>
                <a mat-flat-button href="https://www.google.com/" target="_blank">Link</a>
              </div>
            </section>
            <br>
            <h2>How to use Angular Material Icons</h2>
            <br>
            <h3>
                Wir können Angular Material Icons in dem wir sie wie folge implementieren<br>
                Zuerst müssen wir die MatIconKomponente importieren. Dazu navigieren wir zur
                app.module.ts und importieren das Modul. Anschließend sagen wir Angular, dass es diese Modul in jeder Komponente zur
                Verfügung stellen soll.
            </h3>
            <br>
            <ace-editor [(text)]="importMatIcon"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Mit dem folgenden Befehl können die Icons nun angewenden werden
            </h3>
            <ace-editor [(text)]="snippets[6]" id="materialIcons"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Im folgenden werden einige möglichen Buttons aufgelistet und des weiteren mit Buttons versehen der Befehl mit einem Button sieht folgender Maßen aus.
            </h3>
            <ace-editor [(text)]="snippets[7]"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <section>
                <div class="example-label">Icon</div>
                <div class="example-button-row">
                  <div class="example-flex-container">
                    <button mat-icon-button aria-label="Example icon button with a vertical three dot icon">
                      <mat-icon>more_vert</mat-icon>
                    </button>
                    <button mat-icon-button color="primary" aria-label="Example icon button with a home icon">
                      <mat-icon>home</mat-icon>
                    </button>
                    <button mat-icon-button color="accent" aria-label="Example icon button with a menu icon">
                      <mat-icon>menu</mat-icon>
                    </button>
                    <button mat-icon-button color="warn" aria-label="Example icon button with a heart icon">
                      <mat-icon>favorite</mat-icon>
                    </button>
                    <button mat-icon-button disabled aria-label="Example icon button with a open in new tab icon">
                      <mat-icon>open_in_new</mat-icon>
                    </button>
                  </div>
                </div>
            </section>
            <br>
            <h3>
                Eine Liste aller Icons ist hier <a href="https://www.angularjswiki.com/angular/angular-material-icons-list-mat-icon-list/">hier</a> zu finden.<br>
                Um Icon zu designen ist der einfachste Schritt dies unter ein root Element zu setzen, von welchem die Eigenschaften eine höhere Pio haben. 
                Dies zeigt das folgende Codesnippet.
            </h3>
            <ace-editor [(text)]="snippets[8]"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h2>
                How we can use the Material Tabs
            </h2>
            <br>
            <h3>In Angular Material sind Tabs ein UI-Element, mit dem Benutzer zwischen verschiedenen Inhalten navigieren können. Ein Tab-Element besteht normalerweise aus einer Reihe von Tabs, die horizontal oder vertikal angeordnet sein können, und einem Bereich, in dem der Inhalt des ausgewählten Tabs angezeigt wird.
                <br>
                <br>
                Jeder Tab ist normalerweise mit einer Bezeichnung oder einem Symbol versehen, um den Inhalt zu kennzeichnen, und kann auch eine Badge-Nummer enthalten, um anzuzeigen, ob neue Inhalte verfügbar sind. Wenn der Benutzer auf einen Tab klickt, wird der zugehörige Inhalt in einem separaten Bereich angezeigt.
                <br>
                <br>
                Angular Material stellt eine Reihe von Komponenten bereit, um Tab-Elemente einfach zu erstellen, wie mat-tab-group, mat-tab-nav-bar, mat-tab-link und mat-tab-content. Diese Komponenten können verwendet werden, um Tabs in verschiedenen Formen und Größen zu erstellen und an die spezifischen Anforderungen der Anwendung anzupassen.
                <br>
                <br>
                Tabs eignen sich besonders gut für Anwendungen mit vielen Inhalten, bei denen der Benutzer zwischen verschiedenen Bereichen navigieren muss, ohne die Seite zu verlassen oder neu zu laden. Sie können auch nützlich sein, um Inhalte in übersichtliche Kategorien zu unterteilen und den Benutzern die Navigation durch die Anwendung zu erleichtern.</h3>
            <h3>Der folgende Code Snippet implementiert uns auch wieder hier das Modul</h3>
            <br>
            <ace-editor [(text)]="importMatTab"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>Jetzt können wir das Tabmodul werwenden indem wir den folgenden Code benutzen (Als Beispiel mit 3 Tabs)</h3>
            <ace-editor [(text)]="snippets[11]"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>Das Ergebnis sieht so aus</h3>
            <mat-tab-group>
                <mat-tab label="First"> Content 1 </mat-tab>
                <mat-tab label="Second"> Content 2 </mat-tab>
                <mat-tab label="Third"> Content 3 </mat-tab>
            </mat-tab-group>
            <h3>jetzt passen wir die Farben und den Style noch an etwas sowie bringen etwas mehr Content ins Spiel und erhalten mit folgenden Code folgendes Ergebnis</h3>
            <ace-editor [(text)]="designTabs" id="materialTabs"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <mat-tab-group style="color:white; background-color: rgb(41, 26, 54);" [backgroundColor]="'primary'">
                <mat-tab label="First">
                    <p style="margin:20px;"> 
                        Lorem ipsum dolor sit amet, consetetur sadipscing elitr, 
                        sed diam nonumy eirmod tempor invidunt ut labore et dolore 
                        magna aliquyam erat, sed diam voluptua. At vero eos et accusam 
                        et justo duo dolores et ea rebum. Stet clita kasd gubergren, 
                        no sea takimata sanctus est Lorem ipsum dolor sit amet. 
                        Lorem ipsum dolor sit amet, consetetur sadipscing elitr, 
                        sed diam nonumy eirmod tempor invidunt ut labore et dolore 
                        magna aliquyam erat, sed diam voluptua. At vero eos et accusam 
                        et justo duo dolores et ea rebum. Stet clita kasd gubergren, no 
                        sea takimata sanctus est Lorem ipsum dolor sit amet.
                    </p>
                </mat-tab>
                <mat-tab label="Second">
                    <p style="margin:20px;"> 
                        Lorem ipsum dolor sit amet, consetetur sadipscing elitr, 
                        sed diam nonumy eirmod tempor invidunt ut labore et dolore 
                        magna aliquyam erat, sed diam voluptua. At vero eos et accusam 
                        et justo duo dolores et ea rebum. Stet clita kasd gubergren, 
                        no sea takimata sanctus est Lorem ipsum dolor sit amet. 
                        Lorem ipsum dolor sit amet, consetetur sadipscing elitr, 
                        sed diam nonumy eirmod tempor invidunt ut labore et dolore 
                        magna aliquyam erat, sed diam voluptua. At vero eos et accusam 
                        et justo duo dolores et ea rebum. Stet clita kasd gubergren, no 
                        sea takimata sanctus est Lorem ipsum dolor sit amet.
                    </p>
                </mat-tab>
                <mat-tab label="Third">
                    <p style="margin:20px;"> 
                        Lorem ipsum dolor sit amet, consetetur sadipscing elitr, 
                        sed diam nonumy eirmod tempor invidunt ut labore et dolore 
                        magna aliquyam erat, sed diam voluptua. At vero eos et accusam 
                        et justo duo dolores et ea rebum. Stet clita kasd gubergren, 
                        no sea takimata sanctus est Lorem ipsum dolor sit amet. 
                        Lorem ipsum dolor sit amet, consetetur sadipscing elitr, 
                        sed diam nonumy eirmod tempor invidunt ut labore et dolore 
                        magna aliquyam erat, sed diam voluptua. At vero eos et accusam 
                        et justo duo dolores et ea rebum. Stet clita kasd gubergren, no 
                        sea takimata sanctus est Lorem ipsum dolor sit amet.
                    </p>
                </mat-tab>
            </mat-tab-group>
        </div>

        <br>
        <div class="line"></div>
        <br>


<!--===================================================================Architecture=============================================================================================-->
        <div class="capSection" id="architecture">
            <h1>Architecture</h1>

            <h3>
                Softwarearchitektur beschreibt die Struktur und Organisation einer Softwareanwendung auf einer abstrakten Ebene. Es geht dabei um die Gestaltung des Gesamtsystems und die Aufteilung in einzelne Komponenten oder Module sowie die Interaktion zwischen diesen Komponenten.
                <br><br>
                Ziel der Softwarearchitektur ist es, eine stabile, flexible und erweiterbare Software zu entwickeln, die den Anforderungen des Kunden entspricht und dennoch einfach zu warten und zu erweitern ist. Eine gute Architektur kann auch dazu beitragen, dass das System effizient und sicher läuft und leicht skalierbar ist.
                <br><br>
                Eine wichtige Rolle bei der Gestaltung der Softwarearchitektur spielt die Wahl der geeigneten Architekturmuster, wie z.B. Schichtenarchitektur, MVC (Model-View-Controller) oder Microservices-Architektur. Jedes Muster hat seine eigenen Vor- und Nachteile, je nach den Anforderungen und Zielen des Projekts.
                <br><br>
                Ein gutes Beispiel für die Bedeutung der Softwarearchitektur ist eine Webanwendung. Die Architektur der Webanwendung könnte beispielsweise aus einem Frontend, einem Backend und einer Datenbank bestehen. Die Architektur könnte als Schichtenarchitektur organisiert werden, bei der das Frontend, das Backend und die Datenbank als separate Schichten angesehen werden, die miteinander interagieren, um die gewünschten Funktionen bereitzustellen.
            </h3>
            <br>
            <h3>So könnte ein Beispiel in Typescript aussehen</h3>
            <ace-editor [(text)]="exampleArchitecture"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>

            <h3>
                In diesem Beispiel gibt es eine Datenzugriffsschicht, eine Geschäftslogikschicht und eine Präsentationsschicht. Jede Schicht hat eine spezifische Aufgabe und interagiert nur mit den Schichten darüber und darunter, um die gewünschte Funktionalität bereitzustellen.
            </h3>
            <br>
            <h3>
                Eine gute Softwarearchitektur ist wichtig, um komplexe Anwendungen zu strukturieren und zu organisieren. Eine solide Architektur sorgt dafür, dass eine Anwendung skalierbar, wartbar und erweiterbar ist. Eine Architektur beschreibt also, wie eine Anwendung aufgebaut ist und wie die verschiedenen Komponenten miteinander interagieren.
                <br><br>
                Die objektorientierte Programmierung ist eine Herangehensweise an die Entwicklung von Anwendungen, die auf der Verwendung von Objekten basiert. Objekte sind in sich geschlossene Einheiten, die Daten und Funktionalitäten miteinander verbinden. Durch die Verwendung von Objekten kann eine Anwendung modular strukturiert werden, was zu einer besseren Wartbarkeit und Erweiterbarkeit führt.
                <br><br>
                Daher ist es sinnvoll, die Prinzipien der objektorientierten Programmierung in der Softwarearchitektur zu nutzen. Durch die Verwendung von Objekten als Bausteine der Architektur kann eine Anwendung leichter verständlich und einfacher zu warten sein. Eine gut gestaltete objektorientierte Architektur kann auch dazu beitragen, die Wiederverwendbarkeit von Code zu erhöhen und die Entwicklung von Anwendungen zu beschleunigen.
                <br><br>
                Insgesamt ermöglicht die objektorientierte Programmierung in Verbindung mit einer guten Architektur eine saubere, effektive und nachhaltige Entwicklung von Softwareanwendungen.
            </h3>
            <h2>Objektorientiertes Programmieren</h2>
            <h3>
                Die objektorientierte Programmierung (OOP) ist ein Programmierparadigma, das sich auf die Modellierung von Problemen durch die Erstellung von Objekten konzentriert. Ein Objekt besteht aus Daten (Eigenschaften) und Verhalten (Methoden), die in einer einzigen Einheit zusammengefasst sind.
                <br><br>
                Ein Beispiel aus der Realität wäre ein Auto. Ein Auto besteht aus verschiedenen Teilen wie Motor, Rädern, Karosserie, usw., die alle miteinander interagieren, um das Auto zu bilden. Jedes Teil hat seine eigenen Eigenschaften und Verhaltensweisen. Der Motor hat eine Leistung, kann sich drehen und Gas geben. Die Räder können sich drehen und das Auto vorwärts bewegen. Die Karosserie hat eine Farbe und Form. Diese Teile können als Objekte modelliert werden, die miteinander interagieren, um das Auto als Ganzes zu bilden.
            </h3>
            <h3>Hier ist ein Codebeispiel in TypeScript, das das Konzept der OOP veranschaulicht:</h3>
            <ace-editor [(text)]="exampleClass" id="implClass"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                In diesem Beispiel haben wir eine Klasse Person definiert, die Eigenschaften wie name und age hat und eine Methode sayHello definiert, die einen Text ausgibt. Wir erstellen dann eine Instanz der Klasse Person mit dem Namen person1, indem wir den Konstruktor aufrufen und Werte für name und age übergeben. Schließlich rufen wir die Methode sayHello auf, um den Text auszugeben.
            </h3>
            <h2>Services</h2>
            <h3>
                In der Softwareentwicklung sind Services Komponenten, die bestimmte Funktionen bereitstellen, die in der gesamten Anwendung wiederverwendet werden können. Ein Service ist also eine Klasse mit einer bestimmten Funktionalität, die unabhängig von Komponenten und Modulen der Anwendung ist und als Singleton fungiert.
                <br><br>
                Es gibt mehrere Gründe, warum Services in der Softwareentwicklung verwendet werden sollten:
                <br><br>
                • Code-Wiederverwendbarkeit: Ein Service kann in verschiedenen Komponenten und Modulen der Anwendung verwendet werden, um die Funktionalität, die er bereitstellt, zu nutzen.
                <br><br>
                • Single Source of Truth: Ein Service fungiert als einzige Quelle der Wahrheit für bestimmte Daten oder Funktionen, so dass alle Komponenten und Module dieselben Informationen und Funktionen verwenden und manipulieren.
                <br><br>
                • Separation of Concerns: Services ermöglichen eine klare Trennung von Zustandsverwaltung und Logik von der Benutzeroberfläche. Dadurch kann die Anwendung einfacher getestet und gewartet werden.
                <br><br>
                • Dependency Injection: Services können durch Dependency Injection in die Komponenten und Module der Anwendung eingefügt werden, was die Flexibilität und Erweiterbarkeit der Anwendung erhöht.
                <br><br>
                Insgesamt bieten Services eine Möglichkeit, um eine klar strukturierte und wiederverwendbare Anwendung zu erstellen, die leicht zu testen und zu warten ist.
            </h3>
            <h2>Models</h2>
            <h3>
                In der Softwareentwicklung bezieht sich der Begriff "Model" in der Regel auf eine Darstellung von Daten, die verwendet wird, um Daten zu speichern, zu manipulieren und zu präsentieren. Ein Model kann als eine Art Bauplan betrachtet werden, der beschreibt, wie Daten in der Anwendung organisiert werden sollen.
                <br><br>
                Modelle können in verschiedenen Bereichen der Softwareentwicklung eingesetzt werden, wie z. B. in der Datenbank-Modellierung, bei der Daten in einer relationalen Datenbank organisiert werden, oder in der UI-Entwicklung, bei der das Model die Darstellung von Daten auf der Benutzeroberfläche steuert.
                <br><br>
                Ein Model enthält normalerweise alle notwendigen Daten und Informationen, um die damit verbundenen Prozesse zu steuern und zu verwalten. Es kann auch Methoden oder Funktionen enthalten, um diese Daten zu validieren, zu transformieren oder zu manipulieren.
                <br><br>
                Die Verwendung von Models in der Softwareentwicklung hat mehrere Vorteile. Zum einen können Modelle helfen, die Code-Qualität zu verbessern und die Wartbarkeit zu erleichtern, indem sie eine klare und konsistente Struktur für die Datenorganisation bereitstellen. Außerdem können Modelle dazu beitragen, die Code-Wiederverwendbarkeit zu verbessern, da sie als Blaupause für die Verwendung in verschiedenen Teilen der Anwendung dienen können.
                <br><br>
                Darüber hinaus können Models auch dazu beitragen, die Code-Leistung und die Benutzerfreundlichkeit zu verbessern, indem sie die Datenorganisation und -manipulation optimieren. Wenn die Daten gut organisiert sind, kann die Anwendung schneller auf sie zugreifen und sie schneller verarbeiten. Wenn die Benutzer Daten leicht finden und bearbeiten können, verbessert sich auch die Benutzerfreundlichkeit der Anwendung.
                <br><br>
                Zusammenfassend lässt sich sagen, dass die Verwendung von Models eine wichtige Rolle in der Softwareentwicklung spielt, da sie helfen, Daten effektiv zu organisieren, Codequalität und Wartbarkeit zu verbessern, Code-Wiederverwendbarkeit zu ermöglichen und die Code-Leistung und Benutzerfreundlichkeit zu verbessern.
            </h3>
            <h3>Hier sind zwei Beispiel-Models in TypeScript, einmal als Klasse und einmal als Interface, sowie Erklärungen zu den Unterschieden und Kennzeichnungen:</h3>
            <ace-editor [(text)]="exampleModelClass" id="implModClass"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>Erklärung: Die Person-Klasse definiert ein Modell für eine Person mit den Eigenschaften firstName, lastName und age. Der Konstruktor der Klasse erwartet die Werte für diese Eigenschaften als Parameter und weist sie dann den entsprechenden Instanzvariablen zu.</h3>
            <h3>
                Der Konstruktor einer Klasse ist eine spezielle Methode, die beim Erstellen einer neuen Instanz dieser Klasse aufgerufen wird. Der Konstruktor hat den gleichen Namen wie die Klasse und wird verwendet, um die Instanz der Klasse zu initialisieren und den Anfangszustand der Instanz festzulegen.
                <br>
                In TypeScript wird der Konstruktor durch das Schlüsselwort "constructor" definiert. Der Konstruktor kann Parameter entgegennehmen, die verwendet werden, um die Eigenschaften der Klasse zu initialisieren. Innerhalb des Konstruktors können auch weitere Methoden der Klasse aufgerufen werden.
            </h3>
            <ace-editor [(text)]="exampleModelInterface" id="implModInterface"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Erklärung: Das Car-Interface definiert ein Modell für ein Auto mit den Eigenschaften make, model, year, color und features. Das !-Symbol bei der Eigenschaft color kennzeichnet sie als Required-Property, während das ?-Symbol bei der Eigenschaft year sie als optional markiert. Das RequiredCar-Interface kennzeichnet alle Eigenschaften als Required, während das PartialCar-Interface alle Eigenschaften als optional kennzeichnet.
            </h3>
            <h2>Klassen und Interfaces im Vergleich</h2>
            <h3>
                Klassen und Interfaces haben einige Unterschiede:
                <br><br>
                • Klassen können einen Konstruktor und Methoden enthalten, während Interfaces nur Eigenschaften und Methodensignaturen definieren.<br>
                • Klassen erzeugen bei der Instanziierung eine konkrete Objektinstanz, während Interfaces nur als Verträge für Typen und Strukturen dienen.<br>
                • Klassen können vererbt werden, während Interfaces erweitert werden können.<br>
                • Klassen können Implementierungen von Interfaces enthalten.
                <br><br>
                Klassen bieten in der Regel mehr Flexibilität, da sie mehr Funktionen und Verhaltensweisen bieten, während Interfaces eher für die Definition von Datenstrukturen und Typen verwendet werden. Die Wahl zwischen einer Klasse und einem Interface hängt also von den Anforderungen des Programms ab.
            </h3>
            <h3>Damit wir Klassen und Interfaces auf mehrere Dateien auslagern können und in anderen Dateien importieren können benutzen wir das Export Statement</h3>
            <ace-editor [(text)]="export" id="exp"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h2>Aber warum auslagern?</h2>
            <h3>
                Das Auslagern von Services, Funktionen, Klassen, Models und anderen Teilen des Codes in separate Dateien hat mehrere Vorteile:
                <br><br>
                • Wiederverwendbarkeit: Wenn ein Teil des Codes in einer separaten Datei gespeichert wird, kann er leicht in anderen Teilen des Projekts wiederverwendet werden, ohne dass man ihn erneut schreiben muss. Das spart Zeit und reduziert die Fehleranfälligkeit.
                <br><br>
                • Lesbarkeit: Durch das Auslagern des Codes in separate Dateien wird der Code insgesamt lesbarer. Wenn alle Funktionen, Klassen und Models in einer Datei gespeichert werden, wird der Code schnell unübersichtlich und schwieriger zu lesen und zu verstehen.
                <br><br>
                • Modularität: Durch das Auslagern des Codes in separate Dateien wird der Code modularer. Jede Datei kann eine spezifische Aufgabe erfüllen und unabhängig von anderen Dateien sein. Dies erleichtert das Debugging, die Wartung und die Erweiterung des Codes.
                <br><br>
                • Teamarbeit: Das Auslagern des Codes in separate Dateien erleichtert die Zusammenarbeit zwischen verschiedenen Entwicklern im Team. Jeder Entwickler kann an einer separaten Datei arbeiten, ohne dass er den Code anderer Entwickler beeinflusst oder beeinflusst wird.
                <br><br>
                Insgesamt hilft das Auslagern von Code in separate Dateien dabei, den Code lesbarer, wartbarer, erweiterbarer und wiederverwendbarer zu machen, was letztendlich zu einer höheren Qualität und Effizienz des Projekts führt.
            </h3>
        </div>

        <br>
        <div class="line"></div>
        <br>


<!--=====================================================================Concepts================================================================================================-->
        <div class="capSection" id="angular">
            <h1>Concepts in Angular</h1>
            <h3>
                Angular ist ein umfassendes Framework zur Entwicklung von Webanwendungen. Es basiert auf dem Model-View-Controller (MVC) oder Model-View-ViewModel (MVVM) Architekturmuster und nutzt eine Vielzahl von Konzepten, um Entwicklern zu helfen, effektive und wartbare Anwendungen zu erstellen. Hier sind einige der grundlegenden Konzepte in Angular:
                <br><br>
                • Komponenten: Komponenten sind die grundlegenden Bausteine von Angular-Anwendungen. Sie sind abgekapselte Einheiten, die aus einer View (Ansicht), einem Template (Vorlage) und einem Controller (Klasse) bestehen. Komponenten repräsentieren Teile der Benutzeroberfläche einer Anwendung.
                <br>
                • Templates: Templates definieren das Aussehen der Benutzeroberfläche einer Angular-Anwendung. Sie sind in der Regel in HTML geschrieben und können Angular-spezifische Syntax verwenden, um Daten anzuzeigen und Ereignisse zu behandeln.
                <br>
                • Direktiven: Direktiven erweitern die Funktionalität von HTML und ermöglichen es Entwicklern, eigene HTML-Elemente zu erstellen. Sie können auch verwendet werden, um die Verhaltensweise von vorhandenen HTML-Elementen zu ändern.
                <br>
                • Services: Services sind Klassen, die in der Regel zum Teilen von Daten und Funktionen zwischen verschiedenen Komponenten verwendet werden. Sie können auch externe Datenquellen wie APIs oder Datenbanken aufrufen.
                <br>
                • Dependency Injection: Dependency Injection ist ein Konzept, das es Entwicklern ermöglicht, Abhängigkeiten zwischen verschiedenen Komponenten in einer Angular-Anwendung zu verwalten. Es erleichtert das Testen und die Wiederverwendbarkeit von Code.
                <br>
                • Pipes: Pipes sind Funktionen, die verwendet werden, um Daten in der Benutzeroberfläche zu transformieren. Sie können verwendet werden, um Daten zu filtern, zu sortieren oder umzuwandeln.
                <br>
                • Module: Module sind Container für verschiedene Teile einer Angular-Anwendung. Sie werden verwendet, um Komponenten, Dienste und Direktiven zu organisieren und zu gruppieren.
                <br>
                • sRouter: Der Router ist ein Modul, das für die Navigation in einer Angular-Anwendung verantwortlich ist. Er ermöglicht es Benutzern, zwischen verschiedenen Ansichten der Anwendung zu navigieren.
                <br><br>
                Diese Konzepte sind nur ein Teil von dem, was Angular ausmacht, aber sie bilden die Grundlage für die Entwicklung von Angular-Anwendungen. Durch das Verständnis dieser Konzepte können Entwickler effektiver mit dem Framework arbeiten und bessere Anwendungen erstellen.
            </h3>

            <h2>
                Object Orientated Programming in Angular
            </h2>
            <h3>
                In Angular, Objektorientierung (OO) wird durch die Verwendung von TypeScript, einer typisierten Sprache, die auf JavaScript aufbaut, erreicht. TypeScript ermöglicht die Definition von Klassen, die wiederum zur Erstellung von Objekten verwendet werden können.
                <br><br>
                Angular selbst nutzt die Objektorientierung, um die verschiedenen Komponenten der Anwendung in abgekapselte Einheiten zu organisieren. Jede Komponente wird als Klasse implementiert, die Eigenschaften und Methoden enthält, um das Verhalten der Komponente zu definieren. Dadurch wird die Komponente unabhängig und kann leicht wiederverwendet werden.
                <br><br>
                Ein weiterer Aspekt der Objektorientierung in Angular ist die Vererbung. In Angular kann man eine Komponente von einer anderen Komponente erben und die Eigenschaften und Methoden der übergeordneten Komponente erweitern oder überschreiben. Dies ermöglicht es Entwicklern, eine Basis-Komponente zu erstellen, die gemeinsame Funktionalitäten enthält, und dann spezifische Komponenten zu erstellen, die von der Basis-Komponente erben.
                <br><br>
                Zusammenfassend kann gesagt werden, dass Objektorientierung in Angular durch die Verwendung von TypeScript und Klassen ermöglicht wird. Die Verwendung von Klassen und Vererbung ermöglicht es, Komponenten in abgekapselte Einheiten zu organisieren und wiederzuverwenden, was zur Entwicklung von robusten und skalierbaren Anwendungen beiträgt.
            </h3>
            <h2>Services in Angular</h2>
            <h3>
                In Angular sind Services Klassen, die in der Regel zur gemeinsamen Verwendung von Daten und Funktionen zwischen verschiedenen Komponenten verwendet werden. Sie sind eine Möglichkeit, Funktionen und Daten von einer Komponente zu isolieren und sie anderen Komponenten zur Verfügung zu stellen.
                <br>
                Services können Daten von externen Quellen wie Server-APIs oder anderen Diensten abrufen und diese Daten an andere Komponenten weitergeben. Sie können auch dazu verwendet werden, gemeinsame Funktionen bereitzustellen, die von mehreren Komponenten verwendet werden.
            </h3>
            <h3>Um einen Service zu erstellen schreiben wir</h3>
            <div class="codebox" id="generateComponent">
                <div class="codeLine">
                    <h2>
                        {{snippets[12]}}
                    </h2>
                    <button mat-raised-button><span style="color:black"><mat-icon color="">content_copy</mat-icon></span></button>
                </div>
                <div class="codeLine">
                    <h2>
                        {{snippets[13]}}
                    </h2>
                    <button mat-raised-button><span style="color:black"><mat-icon color="">content_copy</mat-icon></span></button>
                </div>
            </div>
            <br>
            <h3>So könnte zum Beispiel ein Service für eine API Abfrage sein</h3>
            <ace-editor [(text)]="exampleService"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <h2>Dependency Injection</h2>

            <h3>
                Dependency Injection (DI) ist ein Entwurfsmuster, das in Angular und anderen Frameworks und Sprachen weit verbreitet ist. Es ermöglicht die zentrale Verwaltung von Abhängigkeiten zwischen verschiedenen Komponenten einer Anwendung.
                <br>
                In Angular bedeutet Dependency Injection, dass eine Abhängigkeit von einer Komponente an eine andere Komponente weitergegeben wird, ohne dass die zweite Komponente sich darum kümmern muss, wie sie diese Abhängigkeit initialisiert. Stattdessen wird die Abhängigkeit automatisch von Angular verwaltet und bereitgestellt.
                <br>
                Um Dependency Injection in Angular zu implementieren, wird normalerweise ein Provider bereitgestellt, der die Abhängigkeit bereitstellt. Der Provider kann eine Klasse, eine Factory-Funktion oder ein Literalobjekt sein.
            </h3>

            <img src="https://angular.io/generated/images/guide/architecture/injector-injects.png">
            <br>
            <h3>
                In Angular wird ein sogenanntes "Dependency Injection" (DI) System verwendet, bei dem Komponenten und Services als "Providers" registriert werden können. Wenn eine Komponente oder ein Service als Provider registriert wird, erstellt Angular eine einzige Instanz dieses Providers und teilt diese Instanz dann allen Komponenten und Services mit, die diesen Provider benötigen.
                <br>
                Dies bedeutet, dass unabhängig davon, wie oft Sie denselben Provider in verschiedenen Komponenten oder Services injizieren, nur eine einzige Instanz dieses Providers erstellt wird. Dies kann dazu beitragen, den Speicherverbrauch zu reduzieren und die Leistung zu verbessern, da nur eine Instanz des Providers verwaltet werden muss.
                <br>
                Allerdings gibt es auch die Möglichkeit, einen Provider als "singleton" oder "per component" zu registrieren. Wenn ein Provider als singleton registriert wird, gibt es nur eine Instanz des Providers im gesamten Anwendungskontext. Wenn er als "per component" registriert wird, gibt es eine separate Instanz des Providers für jede Komponente, die ihn benötigt.
            </h3>
            <h3>schauen wir uns ein Beispiel an</h3>
            <h3>
                Wir benötigen zwei Komponenten und einen Service. 
                Die beiden Komponenten sind dabei Abhängig vom Service. Hier findet Dependency Injection statt. In einer Komponente haben wir zwei Buttons welche 
                eine Variable in der Serviceklasse verändert. Die andere komponente abhängig von dieser Variable und gibt den Wert zurück. Das folgende Chema verdeutlicht dies.
            </h3>
            <img src="./assets/cheme.png">


            
            <br>
            <h3>Wir beginnen damit uns die zwei Komponenten und einen Service zu erstellen</h3>
            <div class="codebox" id="installAngularMaterial">
                <div class="codeLine">
                    <h2>
                        {{snippets[14]}}
                    </h2>
                    <button mat-raised-button><span style="color:black"><mat-icon color="">content_copy</mat-icon></span></button>
                </div>
                <div class="codeLine">
                    <h2>
                        {{snippets[15]}}
                    </h2>
                    <button mat-raised-button><span style="color:black"><mat-icon color="">content_copy</mat-icon></span></button>
                </div>
                <div class="codeLine">
                    <h2>
                        {{snippets[16]}}
                    </h2>
                    <button mat-raised-button><span style="color:black"><mat-icon color="">content_copy</mat-icon></span></button>
                </div>
            </div>
            <br>
            <h3>Als nächstes schreiben wir in den Service eine Variable welche unsere Zahl speichert und eine Funktion welche aufgerufen werden kann um die Variable zu ändern</h3>
            <br>
            <ace-editor [(text)]="dataService" id="DepInj"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>Um die Variable in dem Service jetzt zu verändern initialiseren wir in unserer Buttonkomponente den dataservice und erzeugen ein Objekt aus diesem.
                zusätzlich schreiben wir eine Funktion welche bei einem Button Click die Funktion im Service aufruft. Interessant zu wissen ist auch das wir einfach die Zahl direkt ändern
                können indem wir auf die Variable im Service direkt zugreifen.
            </h3>
            <ace-editor [(text)]="buttonTs"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <h3>Zu guter letzt fehlt noch die Komponente um die Variable aus dem Datenservice auszulesen. Erinnern wir uns zurück an das Konzept in Angular für die Objektorientierung
                Angular erstellt ausschließlich eine Instanz einer Klasse. Das heißt also wenn wir auch hier wieder in den Konstruktor unserer Komponente das Objekt initialiseren
                greifen wir auf die selbe Instanz wie die Instanz der ButtonKomponente zu und genau das ist Dependency Injection. Deswegen erstellen wir für dependency Injections
                auf herkümliche Art und Weise wie es in Typescript der Fall ist (obj = new class()). Wir lesen die Variable aus undgeben sie in einem p tag aus.
                Der Code für die OutputKomponente sieht folgender Maßen aus
            </h3>
            <ace-editor [(text)]="outputTs"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>Noch unten dran gehangen ist das html Dokument der Komponente bitte beachten. Ganz wichtig ist nicht zu vergessen das wir in unserer html Komponente
                einen String der Variable Zahl brauchen. Wir wandeln also in der Funktion, welche uns den Wert zurückgibt diesen in einen String um damit wir ihn ausgeben können.
            </h3>
            <h3>
                Noch einmal zur Zusammenfassung. In dem Datenservice speichern wir unsere Variable und haben eine Funktion um die Variable zu verändern. In der Buttonkomponente
                initialiseren wir ein Objekt aus der Klasse dataService sprich unserem Service und können auf die Variablen in diesem Objekt zugreifen und verändern diese um + und -1.
                Die Outputkomponente initialisert ebenfalls ein Objekt aus der Serviceklasse und zu beachten ist hier das Angular lediglich ein Objekt einer Klasse erzeugt und wir somit
                das sekbe Objekt sowhol in der Button als auch in der Outputkomponente benutzen. In der Outputkomponente haben wir eine Funktion, welche uns einen String der Variable Zahl
                in unserem Service zurück gibt und anschließend ausgibt. Das Ergebnis sieht folgender Maßen aus. Irritieren mag das Design sein und es wirke als eine Komponente aber
                technisch gesehen benutzen wir zwei Komponenten und einen Service.
            </h3>
            <div style="display: flex; gap: 5px; width: auto;background-color: white; height: auto; justify-content: space-between; align-items: center; padding:20px">
                <p>ButtonKomponente</p>
                <p>DataService</p>
                <p>Outputkomponente</p>
            </div>
            <div style="display: flex; gap: 5px; width: 100%;background-color: white; height: auto; justify-content: space-between; align-items: center;">
                <app-button></app-button>
                <p style="margin:0;">Zahl: {{getVar()}}</p>
                <app-output style="width:15%"></app-output>
            </div>
            <br>

        </div>

        <br>
        <div class="line"></div>
        <br>

<!--=======================================================================Forms=================================================================================================-->
        <div class="capSection" id="forms">
            <h1>Forms in Angular</h1>
            <h3>
                Angular Forms ist eine Funktionalität von Angular, mit der Sie Formulare in Ihrer Anwendung erstellen, validieren und verarbeiten können. Es ist ein wichtiger Teil der Datenbindung in Angular, mit dem Benutzerdaten aus Formularen erfassen und speichern können.
                <br>
                Angular Forms bietet eine Vielzahl von Funktionen, darunter:
                <br><br>        
                • Bidirektionale Datenbindung: Die Daten in einem Formular werden automatisch mit dem Modell synchronisiert, das das Formular steuert. Wenn ein Benutzer eine Eingabe macht, wird das Modell automatisch aktualisiert und umgekehrt.
                <br>
                • Validierung: Sie können benutzerdefinierte Validierungsregeln für Formulare definieren, um sicherzustellen, dass Benutzer korrekte Daten eingeben. Sie können auch Standardvalidierungsregeln verwenden, die in Angular Forms integriert sind.
                <br>    
                • Steuerung der Formularinteraktionen: Sie können das Verhalten von Formularen steuern, z.B. was passiert, wenn ein Benutzer auf eine Schaltfläche klickt oder eine Eingabe macht.
                <br>
                • Erstellen von Template-getriebenen Formularen oder Modell-getriebenen Formularen: Sie können entweder Formulare erstellen, die auf Vorlagen basieren oder Formulare, die auf dem Modell basieren.
                <br><br>
                Angular Forms bietet auch eine Vielzahl von Funktionen für komplexe Formulare, z.B. Formulargruppen, verschachtelte Formulare, dynamische Formulare und reaktive Formulare. Mit diesen Funktionen können Sie Formulare erstellen, die auf die Anforderungen Ihrer Anwendung zugeschnitten sind.
            </h3>
            <h2>Simple Form</h2>
            <h3>Mit simplem Forms sind ein festes Format gemeint, was in Typescript festgelegt wird und 
                in der Componennt Html abgebildet wird. Bevor wir jedoch die Form bauen können müssen wir noch einige
                Module ins Appmodule importieren, wir befinden uns ja zusätzlich noch in Angular Material.
                Für die Angular Material Designs importieren wir das MatFormFieldModule und das MatImportModule.
                Außerdem benötigen wir noch das ReactiveFormsModule von Angular. Damit sieht unsere app.module.ts dann
                wie folgt aus.
            </h3>
            <ace-editor [(text)]="FormModule"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Beginnend mit unserer Component.ts bauen wir das Konstrukt für unsere Form. Außerdem
                fügen wir zwei Funktionen hinzu, zum einen jene, welche uns den Inhalt ausgibt wenn man das
                Formular abschickt und zum anderen eine Funktion welche uns den Inhalt der Form teilweise ausfüllt.
                Das ist praktisch wenn man später Daten in einer Datenbank bearbeiten will. Wichtig ist zu beachten,
                dass bei der Ausgabe der Daten in der Submit Funktion wir diese in ein JSON Format bringen wollen,
                um die Daten später in einer Request an die API schicken zu können. Mit der Klasse Json Pipe die wir 
                uns importieren, erzeugen wir ein nues JSON-Objekt aus den Daten des Formulars. In unserer Component.ts
                benötigen wir außerdem noch die Bibliotheken FormGroup, FormControl und Validators. Für weitere
                Erklärungen folgen sie den Komentaren im Code.
            </h3>
            <ace-editor [(text)]="FormTs"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Als nächsten benötigen wir noch unsere Darstellung unserer in Typescript definierter profileForm.
                Wir erstellen ein Formular und binden diese durch Angulars Data und Eventbinding sowohl an unsere
                Formgroup als auch an die submit Funktion. Die einzelnen Elemente für die Eingaben designen wir durch 
                Angular Material und binden jedes einzelne Element an ein Objekt in unserer Formgroup.
                Außerdem fügen wir noch zwei Ausgaben ein, zum einen jene, über die Rechtmäßigkeit des Formulars und
                jene über der Ausgabe unseres Inthaltes.
            </h3>
            <ace-editor [(text)]="formHtml"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Das Ergebnis sieht folgender Maßen aus.
            </h3>
            <app-form></app-form>
            <br>
            <h2>Dynamic Forms</h2>
            <h3>
                Wie ihr bemerkt hat ist dies jedoch alles in einer festen
                Struktur und muss genau im Code deklariert werden. Wenn wir uns in unserem Projekt jedoch 
                an die Request zurück erinnern um eine Lizenz zu beantragen, sehen die Requests jedes mal anders aus.
                Da wir ja in unseren Daten festlegen was alles für eine Lizenz vorhanden sein muss um diese zu beantragen,
                muss unsere Applikation selbstäntig, basierend auf diesen Daten ein Formular erzeugen und genau Dazu
                benötigen wir dynamik, also basierend auf Datenquellen einen Algorythmus der ein Formular erzeugt.
                An dieser Stelle verweise ich auch auf die <a href="https://angular.io/guide/dynamic-form">Angular Dokumentation</a>, ich schneide das Thema nur sehr
                simpel an, in production sollte man sich dann aber an die Dokumentation halten, dort wir das Thema ausführlicher und genauer erleutert.
            </h3>
            <h3>
                Wir beginnen damit uns unser Model zu erstellen. Es handelt sich dabei um ein Model für ein Benutzerprofil. Einfacher Weise lassen wir an der Stelle alle
                Elemente optional.
            </h3>
            <ace-editor [(text)]="dynamicFormModel"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Als nächstes erstellen wir das Script dazu. Am wichtigsten ist an der Stelle unser Formbuilder. Einfacher Weise schreiben wir diesen selber um zu verstehen was
                Dynamik bedeutet, es gibt direkt einen Formbuilder von Angular, dieser ist etwas komplexer und ausführlich in der Dokumentation erklärt. Für näheres Verständnis
                gibt es wieder Kommentare.
            </h3>
            <ace-editor [(text)]="dynamicFormTs"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Als letzte erstellen wir noch unsere html und gehen in einer ngFor-Schleife unsere Formgroup durch und geben die Inhalt mit den Angular Material Modulen aus
            </h3>
            <ace-editor [(text)]="dynamicFormHtml"
            [mode]="'typescript'"
            [theme]="'monokai'"
            [options]="editorOptions "></ace-editor>
            <br>
            <h3>
                Das Ergebnis sieht dann folgender Maßen aus.
            </h3> 
            <app-dynamic-form></app-dynamic-form>
            <br>
            <h3>
                Es ist sehr einfach gehalten, in dem Moment wo wir die Schleife durchgehen und die einzelnen Elemente aus dem
                Model auslesen und als neues Controlobjekt defnieren können wir noch viele weitere Regeln wie für Namen hinzufügen. Genau so ist es nicht schön einfach den Namen 
                des Elements auch für das Label zu nehmen auch hier könnte man extra Regeln einbauen. Der Grund warum wir das jetzt alles gemacht haben ist,
                dass unsere Daten die wir bekommen und die darin enthaltenen Requirements oft unterschiedlich sein werden. Damit wir dann nicht für jeden einzelnen Fall ein extra Formular 
                bauen, muss man dynamisch arbeiten.
            </h3>
            
        </div>

        <br>
        <div class="line"></div>
        <br>

<!--=======================================================================Forms=================================================================================================-->
        <div class="capSection" id="requests">
            <h1>Requests Angular</h1>
            <h3>
                Eine Request (deutsch: Anfrage) ist ein Begriff aus der Informatik und bezieht sich im Allgemeinen auf eine Aufforderung von einem Client an einen Server, 
                um eine bestimmte Aktion durchzuführen oder eine bestimmte Ressource bereitzustellen. Requests sind in der Regel Teil von Client-Server-Kommunikationen 
                und können verschiedene Formen annehmen, je nach Protokoll und Anwendungsfall. Beispielsweise können HTTP-Requests verwendet werden, 
                um Webseiten oder Ressourcen von einem Webserver abzurufen, während SQL-Requests verwendet werden können, u
                m Daten aus einer Datenbank abzufragen oder zu manipulieren. Eine Request besteht normalerweise aus einer Kopfzeile (Header) und einem optionalen 
                Nachrichten- oder Datenkörper. Der Header enthält Metadaten über die Anfrage, wie beispielsweise den verwendeten HTTP-Verb (GET, POST, PUT, DELETE usw.), 
                den URI (Uniform Resource Identifier) und verschiedene andere Informationen, die vom Server verwendet werden können, um die Anfrage zu verarbeiten. 
                Der Nachrichten- oder Datenkörper enthält die eigentlichen Daten, die mit der Anfrage gesendet werden, wie beispielsweise Formulardaten oder JSON-Payloads.
            </h3>
            <img src="./assets/request.jpg">
            <br>
            <h3>
                Damit eine Applikation wie unsere zum Beispiel oder generell unter anderem Webapplikationen nicht direkt Zugriff auf Datenbanken hat, dienen heute API's als
                Schnittstelle. Eine API (Application Programming Interface) ist eine Schnittstelle, die es verschiedenen Software-Anwendungen ermöglicht, miteinander zu kommunizieren und Daten auszutauschen. Sie definiert Regeln, Protokolle und Werkzeuge für den Datenaustausch zwischen verschiedenen Anwendungen, die in der Regel auf unterschiedlichen Plattformen oder Programmiersprachen laufen.
                Eine API ermöglicht es Entwicklern, auf vordefinierte Funktionalitäten und Daten zugreifen, ohne dabei detailliertes Wissen über die zugrundeliegende Implementierung zu haben. Dadurch können Entwickler Zeit sparen und sich auf die Entwicklung ihrer eigenen Anwendungen konzentrieren, ohne sich um die zugrunde liegende Technologie kümmern zu müssen.
                APIs sind heute in vielen Anwendungsbereichen zu finden, von der Integration von sozialen Netzwerken in mobile Anwendungen bis hin zur Steuerung von IoT-Geräten (Internet of Things).
                <br>
                Eine REST-API (Representational State Transfer Application Programming Interface) ist eine Art von API, die auf dem REST-Prinzip basiert. REST ist ein Architekturstil für verteilte Systeme, der auf HTTP-Protokoll aufbaut und als Grundlage für den Datenaustausch zwischen Servern und Clients dient.

                Eine REST-API ermöglicht es den Entwicklern, über HTTP-Methoden (wie GET, POST, PUT, DELETE) auf Ressourcen (z.B. Datenbanktabellen, Dateien, etc.) zuzugreifen und diese zu manipulieren. Die Daten werden dabei meist in einem standardisierten Format wie JSON oder XML übertragen
            </h3>
            <img src="./assets/rest.png">
            <h3>
                Wir stellen also die Anfrage an eine API und erhalten Daten zurück. Um das zu machen benötigen wir ein Ziel, die Art der Request und die Daten wenn wir eine POST,
                PUT, DELETE Methode benutzen. Wir machen das am Beispiel der Graph API welche uns Auskunft über unsere AD gibt. 
            </h3>
            <h3>
                Die Graph API ist eine API, die von Facebook entwickelt wurde und es Entwicklern ermöglicht, auf die Daten und Funktionen von Facebook zuzugreifen. Die Graph API ist benannt nach der Idee, dass alle Daten auf Facebook als "Graph" organisiert sind, wobei jeder Knoten des Graphen eine Entität (z.B. eine Person, eine Seite oder ein Ereignis) und jede Kante eine Beziehung zwischen diesen Entitäten darstellt.

                Die Graph API ist REST-basiert und kann über HTTP-Anfragen abgerufen werden. Sie unterstützt eine Vielzahl von Datenformaten wie JSON, XML und RSS. Entwickler können die Graph API nutzen, um auf öffentliche Daten auf Facebook zuzugreifen oder um Zugriff auf geschützte Daten zu erhalten, wenn der Nutzer der Anwendung die entsprechenden Berechtigungen erteilt hat.

                Die Graph API bietet eine Vielzahl von Funktionen, darunter das Lesen und Schreiben von Beiträgen, das Abrufen von Nutzerprofilen und Seiteninformationen, das Verwalten von Anzeigen und das Verwalten von Gruppen. Durch die Nutzung der Graph API können Entwickler Anwendungen erstellen, die in die Facebook-Plattform integriert sind und eine nahtlose Erfahrung für Nutzer bieten.
            </h3>
            <h3>
                In diesem Kapitel bauen wir uns zwar auch selber die Requests aber ich verweise auch gerne auf den <a href="https://developer.microsoft.com/en-us/graph/graph-explorer">Explorer</a> von Microsoft.
                Dieser listet alle in der API bestehenden Endpunkt auf und zeigt, wie eine Request dafür aussehen könnte.
            </h3>
            <h3>
                Zuerst müssen wir uns ein Objekt aus der http-Modul-Klasse von Angular initialisieren.
            </h3>
            <h3>
                Bevor wir Anfragen an die API stellen können, benötigen wir einen Access Token den wir bekommen wenn wir uns idendifizieren.
                An dieser Stelle würde der Single Sign on stattfinden. Duch diesen erhalten wir dann auch den Token den wir für unsere App brauchen damit wir 
                Anfragen an die API stellen können.
            </h3>
            <h3>
                Codeflow:
            </h3>
            <img src="https://learn.microsoft.com/en-us/azure/active-directory/develop/media/tutorial-v2-javascript-auth-code/diagram-01-auth-code-flow.png">
            <br>
            <h3>
                Jedoch können wir das im Moment nicht machen, da unsere App zuerst im Azure Portal registriert werden müsste.
                Damit uns trotzdem Requests einmal näher anschauen können und ich schlecht eine API schreiben kann die irgendwo gehostet wird, besworgen wir uns den Token über
                den Graph API Explorer auf dem ihr auch die Endpunkte festlegen könnt. Über den <a href="https://developer.microsoft.com/en-us/graph/graph-explorer">Link</a> gelangt
                ihr zum Explorer. Meldet euch bitte dort an und führt die erste Request aus "my profile".
            </h3>
            
            <br>
            <div class="requestSection">
                <h1>GET-Request</h1>
                <form>
                    <button mat-raised-button type="button" (click)="GetRequest()">Get</button>
                    <p>{{GetRes | json}}</p>
                </form>
            </div>
            <br>
            <!--<div class="requestSection">
                <h1>GET-Request</h1>
                <form>
                    <mat-form-field style="width: 100%;">
                        <mat-label for="field"></mat-label>
                        <input matInput id="" type="text" formControlName="">
                    </mat-form-field>
                </form>
            </div>-->
        </div>

    </div>
    <div class="toc">
        <div class="contentToc" [style]="toc">
            <h3>Codesnippets</h3>
            <h4>Angular Material</h4>
            <h5 (click)="scrollToSection('installAngularMaterial')">Install Angular Material</h5>
            <h5 (click)="scrollToSection('materialButtons')">Implement Angular Material Buttons</h5>
            <h5 (click)="scrollToSection('materialIcons')">Implement Angular Material Icons</h5>
            <h5 (click)="scrollToSection('materialTabs')">Implement Angular Material Tabs</h5>
            <h4>Architecture</h4>
            <h5 (click)="scrollToSection('implClass')">Implement Classes</h5>
            <h5 (click)="scrollToSection('implModClass')">Implement Models throught CLasses</h5>
            <h5 (click)="scrollToSection('implModInterface')">Implement Models throught Interfaces</h5>
            <h5 (click)="scrollToSection('exp')">Export Classes and Interfaces</h5>
            <h4>Concepts in Angular</h4>
            <h5 (click)="scrollToSection('DepInj')">Implement Dependency Injections</h5>
            <h4>Forms</h4>
            <h5>Build a simple Form</h5>
            <h5>Build a dynamical Form based on Models</h5>
            <h4>Requests</h4>
            <h5>Important Knoledge to Understand</h5>
            <h5>How to open a Request</h5>
            <h5>How to implement Models</h5>
        </div>
    </div>
</div>